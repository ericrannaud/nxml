#!/usr/bin/env python2

import os
import os.path
import sys
import re
import getopt
import StringIO
import codecs
import xml.etree.ElementTree as et

class SyntaxError(Exception):
  pass

TBLOCK_VERBATIM = r'^(<<<)(%?[\w][\w:]*)[ \t]*'
TBLOCK = r'^(<)(%?[\w][\w:]*)[ \t]*'
TCLOSE_VERBATIM = r'^>>>'
TCLOSE = r'^>'
TATTR = r"^([\w][\w\-:.]*)=(?:\'((?:[^']|\\')*)\'|(\S+))[ \t]*"
TATTR_SINGLE = r"([\w\-]+)[ \t]*"
TOPEN = r'^\|'
TEOL = r'^(?:[ \t\r]*\n)+( *)'
# Must be last.
TANY = r'^(.+?)(<|>|<<<|>>>|\n)'
tokens = [TBLOCK_VERBATIM, TBLOCK, TCLOSE_VERBATIM, TCLOSE, TOPEN, TEOL, TANY]
attrs = [TATTR, TATTR_SINGLE]

def token(input, ignore_tokens=None):
  for t in tokens:
    m = re.match(t, input)
    if m is not None and (ignore_tokens is None or t not in ignore_tokens):
      return t, m
  return None, None

def attr(input):
  for t in attrs:
    m = re.match(t, input)
    if m is not None:
      return t, m
  return None, None

def advance(input, m, gr=0):
  if m is None:
    return input
  return input[len(m.group(gr)):]

def rewind(input, m, gr=0):
  return m.group(gr) + input

def strip_whitespaces(s):
  return s.lstrip(' \t').rstrip(' \t')

def strip_indent(indent, s):
  regex = ''.join([' ' for _ in range(indent)]) + '$'
  return re.sub(regex, '', s)

# When this is called, the tag corresponding to the directive must
# have been ended.
def try_process_directive(orig_builder, parent, el, orig_input, indent):
  is_directive = el.tag.startswith('%')
  if not is_directive:
    return orig_input, indent

  if parent is not None:
    parent.remove(el)
    builder = et.TreeBuilder()
  else:
    # No parent, the directive is at the root.
    _ = orig_builder.close()
    builder = orig_builder

  if el.tag == '%include':
    fn = el.get('path')
    if fn is None:
      raise Exception("Malformed directive '%include', missing required 'path' attribute")
    with codecs.open(fn, encoding='utf-8') as f:
      input = f.read()

    if fn.endswith('.nxml'):
      while True:
        input, ok = parse(builder, input)
        if not ok:
          break
        if parent is None:
          return orig_input, indent
        else:
          root = builder.close()
          parent.append(root)
    else:
      # Not an nxml file, this contains just text.
      parent.text += input

  return orig_input, indent

def block_start(builder, input, tag):
  el = builder.start(tag, {})

  while True:
    tok, m = attr(input)
    input = advance(input, m)
    if tok is None:
      break

    if tok == TATTR:
      el.set(m.group(1), m.group(2))
    else:
      el.set(m.group(1), '')

  return input, el

def block(indent, builder, input, parent):
  tok, m = token(input)
  if m is None or tok not in [TBLOCK, TBLOCK_VERBATIM]:
    return input, indent
  input = advance(input, m)

  chevrons = m.group(1)
  verbatim = len(chevrons) == 3
  if verbatim:
    closer = TCLOSE_VERBATIM
    non_closer = TCLOSE
    starter = [TBLOCK_VERBATIM]
    non_starter = [TBLOCK]
  else:
    closer = TCLOSE
    non_closer = TCLOSE_VERBATIM
    starter = [TBLOCK, TBLOCK_VERBATIM]
    non_starter = []

  tag = m.group(2)
  input, el = block_start(builder, input, tag)

  tok, m = token(input)
  input = advance(input, m)

  if tok == TOPEN:
    indent += 2  # Can continue on next line.
  elif tok == TEOL and len(m.group(1)) > indent:
    # Equivalent to TOPEN.
    indent = len(m.group(1))
  elif tok == TEOL:
    builder.end(tag)
    return try_process_directive(builder, parent, el, input, len(m.group(1)))
  elif tok == closer:
    builder.end(tag)
    return try_process_directive(builder, parent, el, input, indent)
  else:
    raise Exception("Unexpected token '%s': '%s'" % (tok, m.group(0)))

  ignore_tokens = set([TOPEN, non_closer] + non_starter)
  data = ''
  explicit_closer = False
  while True:
    tok, m = token(input, ignore_tokens=ignore_tokens)
    if tok is None:
      closing_indent = indent
      break
    input = advance(input, m)

    if tok in starter:
      # Sub block.
      builder.data(data)
      data = ''

      input = rewind(input, m)
      input, closing_indent = block(indent, builder, input, el)
      if closing_indent < indent:
        break

    elif tok == closer:
      explicit_closer = True
      closing_indent = indent
      break

    elif tok == TEOL and len(m.group(1)) < indent:
      data += strip_indent(indent, m.group(0))
      # Close.
      input = rewind(input, m)
      closing_indent = len(m.group(1))
      break

    elif tok == TEOL:
      data += strip_indent(indent, m.group(0))
      # Continue content.

    elif tok == TANY:
      # Content.
      input = rewind(input, m, 2)
      data += strip_indent(indent, m.group(1))

    else:
      raise Exception("Unexpected token '%s': '%s'" % (tok, m.group(0)))

  if not explicit_closer:
    data = data.rstrip()
  builder.data(data)
  builder.end(tag)
  return try_process_directive(builder, parent, el, input, closing_indent)


re_leading_blanks = re.compile(r'^[\s\n]+', re.S)

def parse(builder, input):
  input = re_leading_blanks.sub('', input)
  if len(input) == 0:
    return input, False
  prev_len = len(input)

  input, _ = block(0, builder, input, None)

  if len(input) == prev_len:
    return input, False
  else:
    return input, True

if __name__ == '__main__':
  opts, args = getopt.getopt(sys.argv[1:], None, ['xml', 'html5'])
  opts = dict(opts)

  with codecs.open(args[0], encoding='utf-8') as f:
    input = f.read()

  builder = et.TreeBuilder()

  with codecs.open(args[1], 'w') as f:

    if '--xml' in opts:
      print>>f, '<?xml version="1.0"?>'
    elif '--html5' in opts:
      print>>f, '<!DOCTYPE html>'

    while True:
      input, ok = parse(builder, input)
      if not ok:
        break
      root = builder.close()
      tree = et.ElementTree(root)

      buf = StringIO.StringIO()
      tree.write(buf, encoding='utf-8')
      s = buf.getvalue()
      buf.close()

      s = re.sub(r'&gt;', '>', s)
      s = re.sub(r'&lt;', '<', s)

      print>>f, s
